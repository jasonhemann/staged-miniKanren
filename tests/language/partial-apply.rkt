#lang racket/base

(require "../../main.rkt"
         "../../test-check.rkt")

(defrel-partial/staged (test-rel rep [y z] [x res])
  (fresh (yz)
    (== y z)
    (== yz `(,y ,z))
    (later (== res (cons x yz)))))

;; All at runtime, like unstaged interpretation of closures.
;;
;; Note that the different applications of the same partial
;; have different values for the later-stage arguments.
(test
 (run 1 (q)
   (fresh (c r1 r2)
     (partial-apply c test-rel 2 2)
     (finish-apply c test-rel 1 r1)
     (finish-apply c test-rel 4 r2)
     (== q `(,r1 ,r2))))
 '(((1 2 2) (4 2 2))))

;; All later, like fully-staged interpretation of closures
(test
 (run 1 (q)
   (staged
    (fresh (c r1 r2)
      (later (partial-apply c test-rel 2 2))
      (later (finish-apply c test-rel 1 r1))
      (later (finish-apply c test-rel 4 r2))
      (later (== q `(,r1 ,r2))))))
 '(((1 2 2) (4 2 2))))

;; Mixed stage, like with a staged closure called in runtime code
(defrel (like-callo c arg res)
  (finish-apply c test-rel arg res))
(test
 (run 1 (q)
   (staged
    (fresh (c r1 r2)
      (later (partial-apply c test-rel 2 2))
      (later (like-callo c 1 r1))
      (later (like-callo c 4 r2))
      (later (== q `(,r1 ,r2))))))
 '(((1 2 2) (4 2 2))))

;; Ensure that specializing a partial application doesn't commit any unifications within
;; to the state accidentally via set-var-val!
(defrel-partial/staged (unify-5 rep [x] [y])
  (== x 5))
(test
 (run 1 (q)
   (staged
    (fresh (x rep)
      (specialize-partial-apply rep unify-5 x)
      (== x 6)
      (== q x))))
 '(6))

(defrel-partial/staged (equalo rep [a b] [c])
  (fallback
   (conde
     [(== a b) (later (== c #t))]
     [(=/= a b) (later (== c #f))])))

;; Regression tests to make sure it's okay for specialize-partial-apply to refer to
;; logic variables bound outside `staged`. Also tests finish-apply before partial-apply
;; producing right generate and check behavior.
(test
 (run* (rt-eq st-eq)
   (fresh (rt st)
     (finish-apply rt equalo rt-eq)
     (finish-apply st equalo st-eq)
     (partial-apply rt equalo 5 5)
     (staged
      (specialize-partial-apply st equalo 5 5))))
 '((#t #t)))
(test
 (run 1 (q)
   (fresh (st)
     (finish-apply st equalo #t)
     (staged
      (specialize-partial-apply st equalo 5 q))))
 '(5))

;; Thanks to Raffi Sanna for this example!
(module specialize-nondet racket
  (require "../../main.rkt")
  
  (defrel/staged (membero elem choices)
    (fresh (h t)
      (== choices (cons h t))
      (conde
        [(== h elem)]
        [(membero elem t)])))
  
  (defrel-partial/staged (membero-staged rep [choices] [elem])
    (membero elem choices))

  ;; When staging this query, staging-time evaluation in membero-staged
  ;; produces multiple answers. The semantics of specialize-partial-apply
  ;; must make this an error! Or, otherwise contain the nondeterminism
  ;; within the specialized relation with a gather or fallback.
  (run* (p)
    (staged
     (gather
      (fresh (vowelo)
        (specialize-partial-apply vowelo membero-staged '(a e i o u))
        (later (finish-apply vowelo membero-staged 'a))
        (later (finish-apply vowelo membero-staged p))))))
  ;; Otherwise, the query would result in generated code like the following.
  ;; Note how there are multiple branches generated by the `gather`, each
  ;; of which has `vowelo` specialized to one of the vowels---a, e, i, o, or u.
  ;; Nondeterminism that should belong to the relation call escapes
  ;; to the context.
  #;(lambda (p3)
      (fresh (temp51)
        (disj
         (==
          temp51
          (apply-rep
           'membero-staged
           '((a e i o u))
           (lambda (_6) (fresh () (== 'a _6)))))
         (==
          temp51
          (apply-rep
           'membero-staged
           '((a e i o u))
           (lambda (_6) (fresh () (== 'e _6)))))
         (==
          temp51
          (apply-rep
           'membero-staged
           '((a e i o u))
           (lambda (_6) (fresh () (== 'i _6)))))
         (==
          temp51
          (apply-rep
           'membero-staged
           '((a e i o u))
           (lambda (_6) (fresh () (== 'o _6)))))
         (==
          temp51
          (apply-rep
           'membero-staged
           '((a e i o u))
           (lambda (_6) (fresh () (== 'u _6))))))
        (finish-apply temp51 (membero-staged (_) ('a)))
        (finish-apply temp51 (membero-staged (_) (p3)))))
  ;; And if we generated that code, we wouldn't get erasure. The query
  ;; above would produce only the single answer '(a) whereas its erasure
  ;; is the following query, that produces the answers '(a e i o u).
  (run* (p)
    (fresh (vowelo)
      (partial-apply vowelo membero-staged '(a e i o u))
      (finish-apply vowelo membero-staged 'a)
      (finish-apply vowelo membero-staged p))))
(require syntax/location)
(test
 (with-handlers ([exn:fail? (lambda (e) (exn-message e))])
   (dynamic-require (quote-module-path specialize-nondet) #f))
 "specialize-partial-apply: staging non-deterministic")